using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Threading.Tasks;
using System.IO;
using System;
using System.Linq;
using TMPro;

/// <summary>
/// This class is a helper class used to export data to files.
/// </summary>
public class DataExporter : SingletonMonobehaviour<DataExporter>
{

    // Show the last file generated
    [SerializeField] private TextMeshPro m_LastFileLabel;
    [SerializeField] private TextMeshPro m_SignalFileLabel;

    /// Check Coroutine is running or not.
    /// This is to prevent calling for multiple coroutines.
    private bool m_CoroutineIsRunning = false;

    /// <summary>
    /// This function start a Coroutine to export data
    /// Mapped to export data button.
    /// </summary>
    public void ExportDataFiles()
    {
        if( m_CoroutineIsRunning == false )
        {
            StartCoroutine( ExportFiles() );
        }
        else
        {
            StopCoroutine( ExportFiles() );
        }        
    }

    /// <summary>
    /// This function exports signal data and left/right heel strike time stamps.
    /// </summary>
    IEnumerator ExportFiles()
    {
       
        m_CoroutineIsRunning = true;

        DateTime dob = DateTime.Now;
        string timeStamp = dob.ToString("MM_dd_yyyyTHH_mm_ss");
        string directoryLocation = Application.persistentDataPath + "/";

        ExportNoiseFiles(directoryLocation, timeStamp);

        m_CoroutineIsRunning = false;
        yield return null;
    }

    /// <summary>
    /// Export the signal data currently being used in the walking trials.    
    /// </summary>
    private async void ExportNoiseFiles( string path, string timeStamp )
    {
        DateTime dob = DateTime.Now;
        string type = NoiseController.Instance.BaseNoise.CurrentPattern.text.Split().Last();
        string postfix = type + "Noise" + "_" + timeStamp + ".txt";
        string fullPath = Path.Combine( path, postfix );
        

        if ( type.Equals("Pink") || type.Equals("Random") )
        {
            foreach( float freq in NoiseController.Instance.BaseNoise.NoiseValueList )
            {
                await WriteToFile( fullPath, freq );
            }
        }      
        else if( type.Equals("ISO") )
        {
            await WriteToFile( fullPath, NoiseController.Instance.BaseNoise.PreferredWalkingSpeed );
        }
        else
        {
            await WriteToFile( fullPath, -9999 );
        }

        CheckFileExists( fullPath, m_SignalFileLabel );
    }

    /// <summary>
    /// Asynchronously write and append line by line to a file.
    /// The using statement before the StreamWrite also closes the StreamReader.
    /// So, no need to close it.
    /// </summary>
    /// <returns></returns>
    private async Task WriteToFile(string path, float line)
    {
        using( StreamWriter myStreamWriter = new StreamWriter( path, append: true ) )
        {
            if( line != -9999 )
            {
                await myStreamWriter.WriteLineAsync( "" + Mathf.Abs(line) );
            }
            else
            {
                await myStreamWriter.WriteLineAsync( "Error Code: " + line );
            }
        } 
    }    

    /// <summary>
    /// Check the file exists and set the name of last file generated by the user.
    /// </summary>
    private void CheckFileExists( string path, TextMeshPro label )
    {
        int idx = path.LastIndexOf('/');
        string fileName = "";

        if( idx != -1 )
        {
            fileName = path.Substring( idx + 1 );
        }

        if ( System.IO.File.Exists( path ) )
        {
            label.text = fileName;
        }
        else
        {
            label.text = "None";
        }
    }
}
